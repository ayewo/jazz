<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>CoValue - Web Client</title>
        <style>
            h1 {
                margin: 0px;
            }
            body {
                font-family: Arial, sans-serif;
                max-width: 1400px;
                margin: 0 auto;
                padding: 5px;
            }
            select,
            button {
                margin: 10px 0;
                padding: 5px;
            }
            .container {
                display: flex;
                align-items: center;
            }
            .fixed-width-span {
                display: inline-block;
                width: 100px;
                background-color: #e0e0e0;
                text-align: right;
            }
            #status {
                margin-top: 20px;
                font-weight: normal;
            }
            #messageLog {
                height: 300px;
                overflow-y: scroll;
                border: 1px solid #ccc;
                padding: 10px;
                margin-bottom: 10px;
            }
            #fileInput {
                border: 2px solid #f20909;
            }
            /* pre { white-space: pre-wrap; } */
        </style>
    </head>
    <body>
        <h1>CoValue - Web Client</h1>

        <div>
            Please select a CoValue:
            <select id="coValueSelect">
                <option value="">Loading CoValue UUIDs...</option>
            </select>
        </div>
        <div>
            <span class="fixed-width-span">Text:</span>
            <button id="loadCoValueText" onclick="loadCoValue(false)">
                1. Load CoValue (Text)
            </button>
            <button id="createCoValueText" onclick="createCoValue(false)">
                2. Create CoValue (Text)
            </button>
            <button id="mutateCoValueText" onclick="mutateCoValue(false)">
                3. Mutate CoValue (Text)
            </button>
        </div>
        <div class="container">
            <span class="fixed-width-span">Binary:</span>
            <div>
                <button id="loadCoValueBinary" onclick="loadCoValue(true)">
                    1. Load CoValue (Binary)
                </button>
                <button id="createCoValueBinary" onclick="createCoValue(true)">
                    2. Create CoValue (Binary)
                </button>
                <button id="mutateCoValueBinary" onclick="mutateCoValue(true)">
                    3. Mutate CoValue (Binary)
                </button>
                <input id="fileInput" type="file" />
            </div>
        </div>
        <div id="messageLog"></div>
        <div id="status"></div>
        <button id="disconnectButton">Disconnect from Server</button>

        <script>
            const SERVER = "localhost:3000";
            const SERVER_WSS = `wss://${SERVER}`;
            const SERVER_WEB = `https://${SERVER}`;
            const SERVER_API = `${SERVER_WEB}/covalue`;
            const CHUNK_SIZE = 100 * 1024; // 100 KB chunks
            const messageLog = document.getElementById("messageLog");
            const coValueSelect = document.getElementById("coValueSelect");
            const statusDiv = document.getElementById("status");
            const disconnectButton =
                document.getElementById("disconnectButton");
            const useWebSocket = true;
            let binaryFlag = false;
            let isEnabled = true;
            let source = null;
            let subscribedCoValue = null;
            const createCoValuesMap = new Map();
            const loadCoValuesMap = new Map();

            const RECONNECT_INTERVAL = 5000; // 5 seconds
            let socket;
            let isConnected = false;
            let reconnectTimeout;

            let retryAttempts = 0;
            const maxRetries = 5;

            function sendWhenReady(data) {
                const ws = getWebSocket();
                if (ws.readyState === WebSocket.OPEN) {
                    ws.send(JSON.stringify(data));
                } else {
                    ws.addEventListener("open", function onOpen() {
                        ws.send(JSON.stringify(data));
                        ws.removeEventListener("open", onOpen);
                    });
                }
            }

            function getWebSocket() {
                if (!socket) {
                    socket = new WebSocket(SERVER_WSS);
                    socket.onopen = (event) => {
                        info(
                            `Connected to WebSocket server at: ${new Date().toISOString()}`,
                        );
                        debug(`${JSON.stringify(event)}`);
                        isConnected = true;
                        clearTimeout(reconnectTimeout);
                    };

                    // socket.onclose = (event) => {
                    //     debug(
                    //         `Disconnected from WebSocket server at: ${new Date().toISOString()}`,
                    //     );
                    //     isConnected = false;
                    //     reconnect();
                    // };
                    socket.onclose = (event) => {
                        info(
                            `Disconnected from WebSocket server at: ${new Date().toISOString()}`,
                        );
                        if (retryAttempts < maxRetries) {
                            setTimeout(() => {
                                connect();
                                retryAttempts++;
                            }, 1000 * retryAttempts);
                        }
                    };

                    socket.onerror = (event) => {
                        debug(`WebSocket error: ${JSON.stringify(event)}`);
                        isConnected = false;
                    };

                    socket.onmessage = (event) => {
                        try {
                            const response = JSON.parse(event.data);
                            if (response.code <= 206) {
                                switch (response.action) {
                                    case "LIST":
                                        handleCoValueList(response.payload);
                                        break;
                                    case "GET":
                                        debug(
                                            `Websocket chunk streaming metadata: ${JSON.stringify(
                                                response,
                                            )} ...`,
                                        );
                                        loadCoValueViaWS(response);
                                        break;
                                    case "POST":
                                        createCoValueViaWS(response);
                                        break;
                                    case "PATCH":
                                        mutateCoValueViaWS(response.payload);
                                        break;
                                    case "SUBSCRIBE":
                                        debug(
                                            `Websocket subscription started: ${JSON.stringify(
                                                response,
                                            )}`,
                                        );
                                        break;
                                    case "MUTATION":
                                        handleMutation(
                                            getEventType(),
                                            response.payload,
                                        );
                                        break;
                                    default:
                                        debug(
                                            `Websocket method unknown: ${response.action}`,
                                        );
                                }
                            } else {
                                debug(
                                    `Websocket request failed: ${JSON.stringify(
                                        response,
                                    )}`,
                                );
                            }
                        } catch (error) {
                            info(`Websocket processing error: ${error.message}`);
                        }
                    };
                }
                return socket;
            }

            function handleCoValueList(uuids) {
                uuids.forEach((uuid) => {
                    const option = document.createElement("option");
                    option.value = uuid;
                    option.textContent = uuid;
                    coValueSelect.appendChild(option);
                });

                info("CoValue UUIDs loaded successfully.");
            }

            function loadCoValueViaWS(response) {
                if (response.code === 200) {
                    // 200 - OK: here signifies a successful response for text CoValue
                    const coValue = response.payload;
                    info(`Loaded (JSON) data for: ${coValue.uuid}.`);
                    logCoValue(coValue);

                } else if (response.code === 202) {
                    // 202 - Accepted: here signifies the start of a binary CoValue download
                    // debug(`Received metadata for file: ${response.payload.fileName} (${response.payload.fileSize}) split into ${response.payload.totalChunks} chunks of ${response.payload.chunkSize} bytes.`);
                    handleJSONChunk(response.payload);

                } else if (response.code === 204) {
                    // 204 - No Content: here signifies the end of a binary CoValue download
                    handleJSONChunk(response.payload);

                } else if (response.code === 206) {
                    // 206 - Partial Content: here signifies chunks from a binary CoValue download
                    handleJSONChunk(response.payload);
                }
            }

            function createCoValueViaWS(response) {
                if (response.code === 200) {
                    // 200 - OK: here means acknowledgement of a chunk from a binary CoValue upload
                    debug(
                        `Chunked upload via websocket acknowledged for: ${response.payload.uuid}.`,
                    );
                } else if (response.code === 201) {
                    // 201 - Created: here is acknowledgement of a textual CoValue creation or the final chunk of a binary CoValue upload
                    // fetch the full covalue from the Map
                    const covalue = createCoValuesMap.get(response.payload.uuid);
                    appendCoValue(covalue);
                    logCoValue(covalue);
                    info(
                        `Created (${
                            isBinary() ? "binary" : "JSON"
                        }) data for: ${response.payload.uuid}.`,
                    );
                }
            }

            function mutateCoValueViaWS(payload) {
                if (isBinary()) {
                    info(`Mutated (binary) data for: ${payload.uuid}.`);
                } else {
                    info(`Mutated (JSON) data for: ${payload.uuid}.`);
                }
            }

            function disconnect() {
                if (isWS()) {
                    if (socket) {
                        debug("Closing the web socket connection.");
                        socket.close();
                    }
                } else {
                    if (source) {
                        debug("Closing the event stream connection.");
                        source.close();
                    }
                }
            }

            async function onPageLoad() {
                debug(`isBinary flag was set to: ${isBinary()}.`);
                debug(`WebSocket support flag was set to: ${isWS()}.`);
                const uuid = getMutationUUID();

                if (uuid) {
                    // Subscribe to Server-Sent Events (SSE) of the CoValue specified by its uuid.
                    connect(uuid);
                    appendCoValue({ uuid: uuid });
                    // Allow the connection to be closed.
                    disconnectButton.addEventListener("click", () => {
                        isEnabled = !isEnabled;

                        if (isEnabled) {
                            connect(uuid);
                            disconnectButton.innerText =
                                "Disconnect from Server";
                        } else {
                            disconnect();
                            disconnectButton.innerText = "Reconnect to Server";
                        }
                    });
                } else {
                    // Load all CoValue uuids.
                    try {
                        if (isWS()) {
                            sendWhenReady({
                                action: "LIST",
                                binary: isBinary(),
                            });
                        } else {
                            const response = await fetch(SERVER_API); // Appending '?all=1' will fetch all.
                            const uuids = await response.json();
                            handleCoValueList(uuids);
                            disconnectButton.disabled = true;
                        }
                    } catch (error) {
                        info(
                            `Error trying to load CoValue UUIDs: ${error.message}`,
                        );
                    }
                }
            }

            function getMutationUUID() {
                const urlParams = new URLSearchParams(window.location.search);
                return urlParams.get("uuid");
            }

            function getMutationUserAgent() {
                const urlParams = new URLSearchParams(window.location.search);
                return urlParams.get("ua");
            }

            function isBinary() {
                if (
                    !binaryFlag &&
                    new URLSearchParams(window.location.search).get(
                        "binary",
                    ) === "true"
                ) {
                    binaryFlag = true;
                }
                return binaryFlag;
            }

            function isWS() {
                return useWebSocket;
            }

            function getEndpoint(uuid, isBinary) {
                if (uuid) {
                    return isBinary
                        ? `${SERVER_API}/${uuid}/binary`
                        : `${SERVER_API}/${uuid}`;
                } else {
                    return isBinary ? `${SERVER_API}/binary` : `${SERVER_API}`;
                }
            }

            function info(text) {
                statusDiv.textContent = text;
                console.info(text);
            }

            function debug(text) {
                console.log(text);
            }

            function logCoValue(coValue) {
                const messageElement = document.createElement("pre");
                const codeElement = document.createElement("code");

                if (Object.hasOwn(coValue, "file") && coValue.file.bindata) {
                    const copy = Object.assign(
                        {},
                        {
                            uuid: coValue.uuid,
                            file: {
                                name: coValue.file.name,
                                size: coValue.file.size,
                                note: coValue.file.note,
                            },
                        },
                    );
                    codeElement.innerHTML = JSON.stringify(copy, null, 5);

                    const blob = new Blob([coValue.file.bindata], { type: "application/octet-stream" });
                    const url = URL.createObjectURL(blob);

                    const a = document.createElement('a');
                    a.href = url;
                    a.download = coValue.file.name;
                    a.textContent = `Download CoValue: ${coValue.uuid} (${coValue.file.name})`;
                    a.style.display = 'block';
                    messageElement.appendChild(a);
                    a.click();

                    // Clean up
                    setTimeout(() => {
                        messageElement.removeChild(a);
                        URL.revokeObjectURL(url);
                    }, 7000);

                } else {
                    codeElement.innerHTML = JSON.stringify(coValue, null, 5);
                }
                messageElement.appendChild(codeElement);
                messageLog.appendChild(messageElement);
                messageLog.scrollTop = messageLog.scrollHeight;
            }

            function appendCoValue(coValue) {
                if (
                    ![...coValueSelect.children].some(
                        (option) => option.value === coValue.uuid,
                    )
                ) {
                    const option = document.createElement("option");
                    option.value = coValue.uuid;
                    option.text = coValue.uuid;
                    coValueSelect.appendChild(option);
                    coValueSelect.value = option.value;
                }
            }

            function connect(uuid) {
                if (!uuid) {
                    return;
                }

                const ua = getMutationUserAgent();
                subscribedCoValue = { uuid: uuid };

                if (isWS()) {
                    sendWhenReady({
                        action: "SUBSCRIBE",
                        binary: isBinary(),
                        payload: { uuid: `${uuid}`, ua: `${ua ?? "0"}` },
                    });
                } else {
                    source = new EventSource(
                        `${SERVER_API}/${uuid}/subscribe/${ua ?? "0"}`,
                    );
                    source.onopen = (event) => {
                        info(
                            `Connection to the event stream was opened: ${JSON.stringify(
                                event,
                            )}`,
                        );
                        disconnectButton.disabled = false;
                    };

                    source.onerror = (event) => {
                        if (event.readyState === EventSource.CLOSED) {
                            console.error("Connection to the event stream was closed");
                        } else {
                            console.error(
                                "Connection to the event stream raised an error: ",
                                event,
                            );
                        }
                    };

                    source.onclose = function() {
                        info(
                            `Disconnected from event stream server at: ${new Date().toISOString()}`,
                        );
                        if (retryAttempts < maxRetries) {
                            setTimeout(() => {
                                connect();
                                retryAttempts++;
                            }, 1000 * retryAttempts);
                        }
                    };

                    const eventType = getEventType();
                    source.addEventListener(eventType, (event) => {
                        const data = JSON.parse(event.data);
                        handleMutation(eventType, data);
                    });
                }
            }

            function getEventType() {
                return isBinary() ? "binary" : "text";
            }

            function handleMutation(eventType, data) {
                if (data.field === "file.data") {
                    subscribedCoValue.file = { data: data.value };
                } else {
                    subscribedCoValue[data.field] = data.value;
                }
                logCoValue(subscribedCoValue);
                info(
                    `Mutation event => CoValue ${subscribedCoValue.uuid} '${
                        data.field
                    }' was updated to '${
                        eventType === "binary"
                            ? "** 100KB binary (in base64) **"
                            : data.value
                    }'.`,
                );
            }

            // function reconnect() {
            //     if (!isConnected && isEnabled) {
            //         debug(
            //             `Attempting to reconnect in ${
            //                 RECONNECT_INTERVAL / 1000
            //             } seconds...`,
            //         );
            //         reconnectTimeout = setTimeout(() => {
            //             debug("Attempting to reconnect...");
            //             connect();
            //         }, RECONNECT_INTERVAL);
            //     }
            // }

            async function createCoValueJSON(url = "", coValue = {}) {
                if (isWS()) {
                    sendWhenReady({
                        action: "POST",
                        binary: false,
                        payload: coValue,
                    });
                } else {
                    const response = await fetch(url, {
                        method: "POST",
                        headers: {
                            "Content-Type": "application/json",
                        },
                        body: JSON.stringify(coValue),
                    });

                    if (!response.ok) {
                        throw new Error(
                            `HTTP error! Status: ${response.status}`,
                        );
                    }
                    appendCoValue(coValue);
                    logCoValue(coValue);
                    info(`Created (JSON) data for: ${coValue.uuid}.`);
                }
            }

            async function loadCoValueViaHTTP(uuid, isBinary) {
                const url = getEndpoint(uuid, isBinary);
                info(`Loading ${uuid} via ${url}...`);
                if (isBinary) {
                    const response = await fetch(url);
                    if (!response.ok) {
                        const errorData = await response.json();
                        debug(
                            `Binary CoValue download failed: ${JSON.stringify(
                                errorData,
                            )}`,
                        );
                        throw new Error(
                            `HTTP Status: ${
                                response.status
                            }. Error: ${JSON.stringify(errorData)}.`,
                        );
                    }

                    const reader = response.body.getReader();
                    const decoder = new TextDecoder();
                    let buffer = '';

                    while (true) {
                        const { done, value } = await reader.read();
                        if (done) {
                            break;
                        }

                        buffer += decoder.decode(value, { stream: true });

                        // Process '\n' delimited JSON chunks streamed by the server
                        let newlineIndex;
                        while ((newlineIndex = buffer.indexOf('\n')) !== -1) {
                            const jsonStr = buffer.slice(0, newlineIndex);
                            buffer = buffer.slice(newlineIndex + 1);

                            if (jsonStr.trim()) {
                                const chunk = JSON.parse(jsonStr);
                                handleJSONChunk(chunk);
                            }
                        }
                    }

                } else {
                    const response = await fetch(url);
                    const coValue = await response.json();
                    info(`Loaded (JSON) data for: ${uuid}.`);
                    logCoValue(coValue);
                }
            }

            function handleJSONChunk(chunk) {
                let state = loadCoValuesMap.get(chunk.uuid);
                try {
                    switch (chunk.type) {
                        case "start":
                            state = {
                                fileMetadata: null,
                                chunks: [],
                                contentLength: 0,
                                receivedLength: 0
                            };
                            loadCoValuesMap.set(chunk.uuid, state);

                            debug(`Received file metadata for CoValue: ${chunk.uuid} => ${chunk.fileName} (${chunk.fileSize}) split into ${chunk.totalChunks} chunks of ${chunk.chunkSize} bytes.`);
                            state.fileMetadata = { ...chunk };

                            // Start of a streaming download.
                            state.chunks = new Array(chunk.totalChunks);
                            state.contentLength = chunk.fileSize;
                            break;

                        case "chunk":
                            if (!state) {
                                throw new Error(`Received file chunk before file metadata for CoValue: ${chunk.uuid}`);
                            }

                            const binaryData = base64ToUint8Array(chunk.data);
                            state.chunks[chunk.chunkIndex] = binaryData;
                            state.receivedLength += binaryData.byteLength;

                            debug(`Received chunk: ${chunk.chunkIndex + 1}/${state.fileMetadata.totalChunks} (with chunk size: ${binaryData.byteLength}) for CoValue ${chunk.uuid}`);
                            break;

                        case "end":
                            // End of stream
                            if (!state) {
                                throw new Error(`Received end chunk before file metadata for CoValue: ${chunk.uuid}`);
                            }

                            if (state.chunks.some(chunk => chunk === undefined || chunk === null)) {
                                throw new Error(`Some chunks are missing for CoValue ${state.fileMetadata.uuid}`);
                            }
                            debug(`File chunks for CoValue: ${chunk.uuid} downloaded successfully.`);

                            handleBinaryCoValue(
                                chunk.uuid,
                                state.receivedLength,
                                state.contentLength,
                                state.chunks,
                                state.fileMetadata
                            );

                            // Clean up
                            loadCoValuesMap.delete(chunk.uuid);
                            break;

                        case "error":
                            // Error from server
                            throw new Error(`Server error: ${chunk.message}`);
                    }
                } catch (error) {
                    console.error('Error processing chunk:', error);
                    statusDiv.textContent = `Error processing stream data: ${error.message}`;
                }
            }

            function handleBinaryCoValue(
                uuid,
                receivedLength,
                contentLength,
                chunks,
                fileMetadata
            ) {
                console.assert(contentLength === receivedLength, `Some chunks were lost because ${contentLength} !== ${receivedLength}`);
                let binaryData = new Uint8Array(contentLength);
                let position = 0;
                for (let chunk of chunks) {
                    binaryData.set(chunk, position);
                    position += chunk.length;
                }

                const coValue = { uuid: uuid };
                coValue.file = {
                    name: fileMetadata.fileName,
                    size: contentLength,
                    note: "** 50MB binary **",
                    bindata: binaryData,
                };
                info(
                    `Loaded (binary) data for: ${uuid} (${contentLength} bytes).`,
                );
                logCoValue(coValue);
            }

            async function loadCoValue(isBinary) {
                binaryFlag = isBinary;
                const uuid = coValueSelect.value;

                if (!uuid) {
                    info("Please, select a CoValue first.");
                    return;
                }

                try {
                    if (isWS()) {
                        sendWhenReady({
                            action: "GET",
                            binary: isBinary,
                            payload: { uuid: `${uuid}` },
                        });
                    } else {
                        await loadCoValueViaHTTP(uuid, isBinary);
                    }
                } catch (error) {
                    info(`Error loading CoValue: ${error.message}`);
                }
            }

            async function createCoValue(isBinary) {
                binaryFlag = isBinary;
                const url = getEndpoint(undefined, isBinary);
                const coValue = { uuid: crypto.randomUUID() };
                coValue.lastUpdated = new Date();
                createCoValuesMap.set(coValue.uuid, coValue);
                debug(
                    `Attempting to add new CoValue with UUID: ${coValue.uuid} via ${url}.`,
                );

                try {
                    if (isBinary) {
                        const file =
                            document.getElementById("fileInput").files[0];
                        if (!file) {
                            alert("Please select a binary file for upload.");
                            return;
                        }

                        await createCoValueBinary(url, coValue, file);
                        coValue.file = {
                            name: file.name,
                            size: file.size,
                            note: "** 50MB binary **",
                        };

                        if (!isWS()) {
                            debug(
                                `Creating (binary) data for ${coValue.uuid} ... file upload complete.`,
                            );
                            appendCoValue(coValue);
                            logCoValue(coValue);
                            info(`Created (binary) data for: ${coValue.uuid}.`);
                        }
                    } else {
                        if (window.faker) {
                            coValue.author = faker.person.fullName();
                            coValue.title = faker.lorem.words({
                                min: 3,
                                max: 5,
                            });
                            coValue.summary = faker.lorem.sentence();
                            coValue.preview = faker.lorem.lines({
                                min: 200,
                                max: 200,
                            }); // 200 lines ~= 10KB of text
                        } else {
                            coValue.author = generateTextData();
                            coValue.title = generateTextData();
                            coValue.summary = generateTextData();
                            coValue.preview = generateTextData();
                        }

                        await createCoValueJSON(url, coValue);
                    }
                } catch (error) {
                    info(
                        `Error creating CoValue (isBinary: ${isBinary}): ${error.message}`,
                    );
                }
            }

            async function base64EncodeChunk(chunk) {
                try {
                    const arrayBuffer = await chunk.arrayBuffer();
                    const uint8Array = new Uint8Array(arrayBuffer);
                    return btoa(String.fromCharCode.apply(null, uint8Array));
                } catch (error) {
                    console.error("Error encoding to base64:", error);
                }
            }

            async function createCoValueBinary(url = "", coValue = {}, file) {
                const totalChunks = Math.ceil(file.size / CHUNK_SIZE);

                for (
                    let chunkIndex = 0;
                    chunkIndex < totalChunks;
                    chunkIndex++
                ) {
                    const start = chunkIndex * CHUNK_SIZE;
                    const end = Math.min(file.size, start + CHUNK_SIZE);
                    const chunk = file.slice(start, end);
                    const base64Chunk = await base64EncodeChunk(chunk);
                    const payload = {
                        uuid: coValue.uuid,
                        filename: file.name,
                        chunk: chunkIndex,
                        chunks: totalChunks,
                        base64: base64Chunk,
                    };

                    try {
                        if (isWS()) {
                            sendWhenReady({
                                action: "POST",
                                binary: true,
                                payload: payload,
                            });
                        } else {
                            const response = await fetch(url, {
                                headers: {
                                    "Content-Type": "application/json",
                                },
                                method: "POST",
                                body: JSON.stringify(payload),
                            });

                            if (!response.ok) {
                                throw new Error(
                                    `HTTP status: ${response.status}`,
                                );
                            } else {
                                debug(
                                    `Chunk ${
                                        chunkIndex + 1
                                    }/${totalChunks} uploaded successfully`,
                                );
                            }
                        }
                    } catch (error) {
                        console.error(
                            `Upload failed at chunk: ${
                                chunkIndex + 1
                            }/${totalChunks}`,
                            error,
                        );
                        throw error;
                    }
                }
            }

            async function mutateCoValue(isBinary) {
                binaryFlag = isBinary;
                const uuid = coValueSelect.value;

                if (!uuid) {
                    info("Please, select a CoValue first.");
                    return;
                }

                const url = getEndpoint(uuid, isBinary);
                const coValue = { uuid: uuid };
                info(
                    `Mutating CoValue with UUID: ${coValue.uuid} via ${url}...`,
                );

                try {
                    if (isBinary) {
                        const blob = generateBinaryData(); // ~100KB CoValue mutation
                        const blobInBase64 = await blobToBase64(blob);
                        coValue.file = {
                            data: blobInBase64,
                            size: blobInBase64.length,
                            note: "** 100KB binary **",
                        };

                        if (isWS()) {
                            sendWhenReady({
                                action: "PATCH",
                                binary: isBinary,
                                payload: {
                                    uuid: coValue.uuid,
                                    file: coValue.file,
                                },
                            });
                        } else {
                            const response = await fetch(url, {
                                method: "PATCH",
                                headers: {
                                    "Content-Type": "application/json",
                                },
                                body: JSON.stringify({
                                    file: coValue.file,
                                }),
                            });
                            if (!response.ok) {
                                throw new Error(
                                    `HTTP error! status: ${response.status}`,
                                );
                            }
                            info(
                                `Mutated (binary) data for: ${coValue.uuid}.`,
                            );
                        }
                    } else {
                        coValue.title = window.faker
                            ? faker.lorem.words({ min: 4, max: 5 }) // ~50-byte CoValue mutation
                            : generateTextData();

                        if (isWS()) {
                            sendWhenReady({
                                action: "PATCH",
                                binary: isBinary,
                                payload: coValue,
                            });
                        } else {
                            const response = await fetch(url, {
                                method: "PATCH",
                                headers: {
                                    "Content-Type": "application/json",
                                },
                                body: JSON.stringify({
                                    title: coValue.title,
                                }),
                            });
                            if (!response.ok) {
                                throw new Error(
                                    `HTTP error! status: ${response.status}`,
                                );
                            }
                            info(
                                `Mutated (JSON) data for: ${coValue.uuid}.`,
                            );
                        }
                    }
                    logCoValue(coValue);
                } catch (error) {
                    info(`Error mutating CoValue: ${error.message}`);
                }
            }

            function generateTextData() {
                const chars =
                    "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
                let result = "";
                for (let i = 0; i < 50; i++) {
                    result += chars.charAt(
                        Math.floor(Math.random() * chars.length),
                    );
                }
                return result;
            }

            function generateBinaryData() {
                const binaryData = new Uint8Array(CHUNK_SIZE);
                for (let i = 0; i < CHUNK_SIZE; i++) {
                    binaryData[i] = Math.floor(Math.random() * 256);
                }
                return new Blob([binaryData], {
                    type: "application/octet-stream",
                });
            }

            function blobToBase64(blob) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();

                    // Convert the Blob to a base64 encoded string
                    reader.onloadend = () => {
                        const base64String = reader.result.split(",")[1]; // remove "data:..." part
                        resolve(base64String);
                    };

                    reader.onerror = reject;
                    reader.readAsDataURL(blob); // read blob as data URL, base64 encoded
                });
            }

            function base64ToUint8Array(base64) {
                const binaryString = atob(base64);
                const bytes = new Uint8Array(binaryString.length);
                for (let i = 0; i < binaryString.length; i++) {
                    bytes[i] = binaryString.charCodeAt(i);
                }
                return bytes;
            }

            // Load CoValue UUIDs or subscribe to SSE on page load
            window.onload = onPageLoad;
        </script>
        <script type="module">
            document.addEventListener("DOMContentLoaded", async () => {
                if (!getMutationUUID()) {
                    const { faker } = await import(
                        `${SERVER_WEB}/faker/index.mjs`
                    );
                    window.faker = faker;
                }
            });
        </script>
    </body>
</html>
